## Java数组擦除机制

**Java支持定义泛型数组,但不允许new**

List<String>[] lists = null; 可以

List<String>[] lists = new List<String> [10]();不可以

导致这个问题的原因虽然是类型擦除，但是是数组的类型擦除加上泛型擦除共同造成的。在数组不带泛型的情况下如 A[] 在运行时其实就是Object[],理论上我们可以进行错误的赋值如obj[0]=new B() 但是JVM在这一句会插入一个类型检查，从而抛出一个异常。而带泛型的数组，由于泛型的类型也被擦除，所以List<Integer>和 List<String>在运行时没有任何的差别，也就是说此时的类型检查会认为这两个类型是相同的 ，这个机制就失效了，我们的程序在运行时可能就出现不可预见的错误。

普通对象的new就更好理解

关键点还是在于new与泛型擦除,

由于泛型擦除机制的存在,实际上所有的new T最终都等价于new Object,这和我们预期的new String完全不一样,根本无法保证程序的正确性.而这个缺陷也是因为泛型在运行时被擦除成Object导致的

所以与其说不支持泛型数组，归根到底还是不支持运行时的类型运算符

（引用类型的数组在new时其实new出来的是这个类型的引用，而不是真实的对象 可以把他理解为指针)

## 内存中存储的都是二进制数字，计算机是怎么样将它在屏幕上以十进制显示出来的？

计算机如何将二进制“转化”为十进制

https://www.zhihu.com/question/554776685?utm_id=0

通过对10的二进制1010不断取模,记录余,再对模继续取模,就得到了每一位的二进制表达,最后再通过ascii的映射显示就好了

还有一种bcd码的存储方式以及高效的转码算法，bcd码非常的直观，用4位表示0-9的数字，但因为2进制的4位上限为15，所以在进位上就出现了偏差，所以它的运算不能直接使用二进制的进位

https://blog.csdn.net/eroDuanDian123456/article/details/122551060 仅供参考 加3位移法

## 构造函数复习

1，static 声明的代码块会在其Class对象生成时期调用，也就是类加载时期；
2，其余代码块的本质是一样的，不管是赋值或者别的语句，都会被拼接到外界调用的构造函数的最前部，在构造函数最开始处执行。所以构造函数内部的赋值会覆盖这些外部语句
3，在构造函数内部内部可以通过调用 this()语句来传递调用构造函数,但是this()语句必须放在第一句，且不可以存在循环的构造函数调用

### 子类父类的构造函数

1，子类的构造函数一定会调用父类的构造函数,且一定是第一句,父类的构造函数执行点要比子类代码块中的语句更早;
2，由于这个特性,编译器其实总是隐式的在子类的构造函数中调用了一个super();
所以当我们给父类定义了带参数的构造函数却没有空构造函数时,编译器就无法替我们自动调用super,我们就必须手动自己调用带参数的super(args);
3，由于显式的super语句和this语句都要求必须在构造函数体为第一句,所以它们俩无法同时被显式调用;如果父类有空的构造函数那么我们不用显示调用super则此时可以使用this

## package机制

1，类在使用时本质上是使用的全名 java.util.List

2，这种方式在编写代码时太复杂，所以引入了包机制。在class文件的头部通过 package com.test.corp 来申明当前包的路径，路径是和文件夹路径对应的；

3，当用类简写找不到该类文件时，就会首先从当前包名下寻找该类，如果还找不到就从import中的类或包中寻找，还找不到就从java.lang中查找，最后找不到就会报错



## 访问权限与内部类

class只有default和public两种权限, 试想一下 private的class谁都无法访问,有什么意义？至于protected也是同理,只有子类能访问，如果没有子类那也没有存在的意义；

方法和字段的权限就是四种，比较熟悉了。唯一需要注意的或许是 只有类能访问到另一个类时，这些权限才有用，如果连类都访问不到肯定就没法使用类的属性了

内部类也比较熟悉了，嵌套内部类会持有一个外部类的引用所以才能访问外部类；且内部类能够访问外部类的所有private字段。

## classpath 与 jar

不要与package弄混淆，package一方面是提供了一种命名空间，使得“同名”类可以存在，且由于.class文件中使用的是完整类名，package机制可以使得编译器从不完整类名中找到完整类名并将其替换。所以package起作用的时机是编译与编译以前。

而classpath提供的是JVM在运行时需要加载一个类时，JVM要去其中寻找这个.class文件的路径。且该.class文件的存放路径必须符合该类的包名路径。最好不要设置classpath的系统变量，因为这是一个全局的变量，每个项目的路径其实是不一样的；更好的方式是通过

java -cp .;C:\project1; abc.Hello 将classpath通过命令行传入。其中.表示当前目录，找不到的话会去下面一个目录中寻找，每一个子项可以理解为一个“根目录”，JVM在这个根目录中寻找目标class文件，文件的路径要与包名路径一致。

jar包其实就可以理解为上面所说的一个 “根目录”，只不过它将这些散布在各个目录下的class文件归档进了一个.jar(其实就是zip)文件。zip文件内部本身就是有目录结构的，所以行为与包名约束与 直接使用文件目录没有区别。

jar包里面还有一个MANIFEST.MF文件，它可以存放一些信息，譬如 main-class的类名；或者jar包中又包含了其他jar包，假如我们外层jar包使用了内层jar包的某个类，为了找到这个类，外层jar包的MANIFEST.MF文件就需要指明这个内部jar包的classpath



## class文件版本与模块

平时我们经常说的版本多为jdk版本(可以粗略的理解为JVM版本)比如8,11,17等；

不同版本的JVM所能执行的 class文件版本也不同，Java 11 对应的class 文件版本为55  Java17对应的class文件版本为 61;

高版本的JVM能兼容运行低版本的class文件,且高版本的JDK可以指定输出低版本的class文件。但是用高版本的jdk输出低版本的class文件是存在很大风险的，因为高版本的很多api在低版本中不存在，将来在低版本jvm虽然可以运行，但是运行到具体语句就会出错了，而高版本jdk又无法在编译时就发现这些错误，所以要使用目标运行版本的jdk来输出相对应的class文件。

可以通过 javac --release 11 Main.java 或者 javac --source 9 --target 11 Main.java 两种方式指定输出版本。其中source属性使得JDK将源码视为Java 9 兼容版本(略微有些不理解 源码到底指的是什么)，target指定输出的为Java 11对应的class版本 即55

## 模块

Java 9引入了 模块，目的是解决jar包之间在外部无法表示依赖关系，很容易因为jar包漏写导致运行时classnotfound

类型为.jmod 模块名就是文件名，依赖关系由内部的module-info.class 指定

如java.base.jmod 所有模块都直接或间接的依赖该模块，该模块不依赖其他模块

jmod文件可以包含本地代码（JNI与so文件 应该是），这在运行时提取和链接有点棘手，因为要考虑目标平台,所以模块在编译和链接时可以使用，运行时不支持jmod

编译过程为.class->jar->jmod. 但是最终的jmod文件不可以直接运行，必须经过jlink指令生成一个小型JRE才能运行(好处是只包含传统jdk中我们需要的模块，大小减少了很多) 链接过程就不深究了，不是我的关注点。

由于jmod中定义了模块的依赖关系，所以如果A模块没有定义依赖B模块的关系，那么A模块是无法使用B模块的方法的，无论B模块中的类的方法是不是public

在思考这个模块的过程中混入了android的打包过程，java程序最终并不会生成一个class.dex文件，所以那些jar包 .class文件等都还是存在的。

https://www.cnblogs.com/IcanFixIt/p/7095839.html

https://java-feature.teaho.net/modular.html

**一些思考: 不要把JVM和Android的虚拟机机制搞混淆,因为安卓平台的应用层本身就是架设在虚拟机之上的,所有上层应用都是通过zygote程序fork出来,zygote本身就初始化好了当前的context以及各类资源，暂且不管fork出来的进程是否会重复拷贝这些资源导致内存的浪费，（应该是不会，如果利用cow copy on write的特性，只有更改才会拷贝一份自己的） apk包打出来是不需要这些资源文件以及核心库的编译后文件的，因为系统本身就给用户层加载好了这些资源，且用户通过fork的机制就可以访问使用。**

**而JVM呢，要知道JVM是脱离平台的，也就是说它理论上应该可以在任何一种操作系统上运行，且它并不是一种系统机制，本质上只是一个第三方的应用，所以你最终打包发布的程序中肯定要包含所有的.class以及对应的依赖的jar包,这一点是和dex文件的差异,android是直接把这些文件统一收到一个dex中，也就解答了在java平台其实可以从jar包中提取so文件的困惑，因为jar包存在于运行平台上；而android的jar包最终会被拆分进dex中，且so不会处理也就丢掉了，必须使用aar，且即便使用aar也是在编译期间就把aar包中的资源extract出来放到对应的目录（res arm x86），运行期间是没有这个所谓的aar的，apk中就只有so .dex res 资源对照表这些文件**

**所以jmod的最终运行行为和传统的应用似乎不同，因为它最终link后是生成一个小型的jre，而以前我们是将jre安装在目标平台上，最终应用只是一些class文件，不同的应用都是通过这同一个jre启动。jmod的好处我想了一下，尽管它使得每个应用最终都生成一个jre，这个jre在硬盘上的空间确实会比只用class文件多，但是这样子是不是也使得应用本身隔离了彼此的jre呢，不必再担心目标平台上单个jre无法满足所有版本的需求，同时每一个jvm在运行时需要重新加载所有的核心资源，因为此时的jvm就只是一个普通的第三方应用，不同于android上的zygote机制，我们无法做所谓的预加载并fork，那么jvm彼此之间就是完全独立的，资源的重复加载是必然存在的，那么每个jvm在运行后都会加载一份jre到内存中，就占据了很多空间。而jmod一定程度上就减轻了这个问题，因为每个应用都用的是自己精简过的jre，虽然也会被重复加载进内存中，但是做到了最少的使用空间。相比于硬盘来说，内存肯定是重要多了，那jmod的优势就体现了出来**（以上关于核心类加载的说法为自己思考，未得到论证，希望日后系统学习jvm或操作系统时可以得到解答）
