## Java数组擦除机制

**Java支持定义泛型数组,但不允许new**

List<String>[] lists = null; 可以

List<String>[] lists = new List<String> [10]();不可以

导致这个问题的原因虽然是类型擦除，但是是数组的类型擦除加上泛型擦除共同造成的。在数组不带泛型的情况下如 A[] 在运行时其实就是Object[],理论上我们可以进行错误的赋值如obj[0]=new B() 但是JVM在这一句会插入一个类型检查，从而抛出一个异常。而带泛型的数组，由于泛型的类型也被擦除，所以List<Integer>和 List<String>在运行时没有任何的差别，也就是说此时的类型检查会认为这两个类型是相同的 ，这个机制就失效了，我们的程序在运行时可能就出现不可预见的错误。

普通对象的new就更好理解

关键点还是在于new与泛型擦除,

由于泛型擦除机制的存在,实际上所有的new T最终都等价于new Object,这和我们预期的new String完全不一样,根本无法保证程序的正确性.而这个缺陷也是因为泛型在运行时被擦除成Object导致的

所以与其说不支持泛型数组，归根到底还是不支持运行时的类型运算符

（引用类型的数组在new时其实new出来的是这个类型的引用，而不是真实的对象 可以把他理解为指针)

## 内存中存储的都是二进制数字，计算机是怎么样将它在屏幕上以十进制显示出来的？

计算机如何将二进制“转化”为十进制

https://www.zhihu.com/question/554776685?utm_id=0

通过对10的二进制1010不断取模,记录余,再对模继续取模,就得到了每一位的二进制表达,最后再通过ascii的映射显示就好了

还有一种bcd码的存储方式以及高效的转码算法，bcd码非常的直观，用4位表示0-9的数字，但因为2进制的4位上限为15，所以在进位上就出现了偏差，所以它的运算不能直接使用二进制的进位

https://blog.csdn.net/eroDuanDian123456/article/details/122551060 仅供参考 加3位移法

## 构造函数复习

1，static 声明的代码块会在其Class对象生成时期调用，也就是类加载时期；
2，其余代码块的本质是一样的，不管是赋值或者别的语句，都会被拼接到外界调用的构造函数的最前部，在构造函数最开始处执行。所以构造函数内部的赋值会覆盖这些外部语句
3，在构造函数内部内部可以通过调用 this()语句来传递调用构造函数,但是this()语句必须放在第一句，且不可以存在循环的构造函数调用

### 子类父类的构造函数

1，子类的构造函数一定会调用父类的构造函数,且一定是第一句,父类的构造函数执行点要比子类代码块中的语句更早;
2，由于这个特性,编译器其实总是隐式的在子类的构造函数中调用了一个super();
所以当我们给父类定义了带参数的构造函数却没有空构造函数时,编译器就无法替我们自动调用super,我们就必须手动自己调用带参数的super(args);
3，由于显式的super语句和this语句都要求必须在构造函数体为第一句,所以它们俩无法同时被显式调用;如果父类有空的构造函数那么我们不用显示调用super则此时可以使用this

## package机制

1，类在使用时本质上是使用的全名 java.util.List

2，这种方式在编写代码时太复杂，所以引入了包机制。在class文件的头部通过 package com.test.corp 来申明当前包的路径，路径是和文件夹路径对应的；

3，当用类简写找不到该类文件时，就会首先从当前包名下寻找该类，如果还找不到就从import中的类或包中寻找，还找不到就从java.lang中查找，最后找不到就会报错



## 访问权限与内部类

class只有default和public两种权限, 试想一下 private的class谁都无法访问,有什么意义？至于protected也是同理,只有子类能访问，如果没有子类那也没有存在的意义；

方法和字段的权限就是四种，比较熟悉了。唯一需要注意的或许是 只有类能访问到另一个类时，这些权限才有用，如果连类都访问不到肯定就没法使用类的属性了

内部类也比较熟悉了，嵌套内部类会持有一个外部类的引用所以才能访问外部类；且内部类能够访问外部类的所有private字段。

## classpath 与 jar

不要与package弄混淆，package一方面是提供了一种命名空间，使得“同名”类可以存在，且由于.class文件中使用的是完整类名，package机制可以使得编译器从不完整类名中找到完整类名并将其替换。所以package起作用的时机是编译与编译以前。

而classpath提供的是JVM在运行时需要加载一个类时，JVM要去其中寻找这个.class文件的路径。且该.class文件的存放路径必须符合该类的包名路径。最好不要设置classpath的系统变量，因为这是一个全局的变量，每个项目的路径其实是不一样的；更好的方式是通过

java -cp .;C:\project1; abc.Hello 将classpath通过命令行传入。其中.表示当前目录，找不到的话会去下面一个目录中寻找，每一个子项可以理解为一个“根目录”，JVM在这个根目录中寻找目标class文件，文件的路径要与包名路径一致。

jar包其实就可以理解为上面所说的一个 “根目录”，只不过它将这些散布在各个目录下的class文件归档进了一个.jar(其实就是zip)文件。zip文件内部本身就是有目录结构的，所以行为与包名约束与 直接使用文件目录没有区别。

jar包里面还有一个MANIFEST.MF文件，它可以存放一些信息，譬如 main-class的类名；或者jar包中又包含了其他jar包，假如我们外层jar包使用了内层jar包的某个类，为了找到这个类，外层jar包的MANIFEST.MF文件就需要指明这个内部jar包的classpath



## class文件版本与模块

平时我们经常说的版本多为jdk版本(可以粗略的理解为JVM版本)比如8,11,17等；

不同版本的JVM所能执行的 class文件版本也不同，Java 11 对应的class 文件版本为55  Java17对应的class文件版本为 61;

高版本的JVM能兼容运行低版本的class文件,且高版本的JDK可以指定输出低版本的class文件。但是用高版本的jdk输出低版本的class文件是存在很大风险的，因为高版本的很多api在低版本中不存在，将来在低版本jvm虽然可以运行，但是运行到具体语句就会出错了，而高版本jdk又无法在编译时就发现这些错误，所以要使用目标运行版本的jdk来输出相对应的class文件。

可以通过 javac --release 11 Main.java 或者 javac --source 9 --target 11 Main.java 两种方式指定输出版本。其中source属性使得JDK将源码视为Java 9 兼容版本(略微有些不理解 源码到底指的是什么)，target指定输出的为Java 11对应的class版本 即55

## 模块

有点写累了，休息明天写
